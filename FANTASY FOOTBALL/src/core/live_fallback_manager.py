"""
Live Fallback Manager

Graceful degradation for live commentary when things go wrong.
Ensures commentary never completely fails during live broadcast.
"""

import asyncio
import logging
import time
from dataclasses import dataclass
from typing import Optional, Callable, Any
from enum import Enum

logger = logging.getLogger(__name__)


class FallbackLevel(Enum):
    """Degradation levels from best to worst"""
    CACHE = "cache"           # Level 1: Instant from cache
    LIVE_AGENT = "live_agent" # Level 2: Generated by Modal agent
    GENERIC = "generic"       # Level 3: Pre-recorded generic
    TEXT_ONLY = "text_only"   # Level 4: No audio, text only


@dataclass
class FallbackResult:
    """Result from fallback chain"""
    level: FallbackLevel
    text: str
    audio: Optional[str]  # base64 or None
    region: str
    agent_type: str
    latency_ms: int
    success: bool
    error: Optional[str] = None


class LiveFallbackManager:
    """
    When things go wrong during live commentary,
    degrade gracefully rather than failing.
    
    Fallback Chain:
    1. Phrase Cache (instant, <50ms)
    2. Modal Agent (timeout-bounded, <500ms)
    3. Generic Pre-recorded (instant, <20ms)
    4. Text-only (no audio)
    
    Usage:
        manager = LiveFallbackManager(phrase_cache, modal_dispatcher)
        result = await manager.get_commentary(event, "kansas_city", "homer")
        
        if result.audio:
            play_audio(result.audio)
        else:
            display_text(result.text)
    """
    
    # Generic reactions by event type (fallback level 3)
    GENERIC_REACTIONS = {
        "touchdown": {
            "text": "TOUCHDOWN!",
            "emotion": "excited",
        },
        "turnover": {
            "text": "Turnover!",
            "emotion": "surprised",
        },
        "big_play": {
            "text": "Big play!",
            "emotion": "excited",
        },
        "interception": {
            "text": "Interception!",
            "emotion": "surprised",
        },
        "injury": {
            "text": "Injury timeout.",
            "emotion": "concerned",
        },
        "penalty": {
            "text": "Flag on the play.",
            "emotion": "neutral",
        },
        "default": {
            "text": "And the play continues...",
            "emotion": "neutral",
        },
    }
    
    def __init__(
        self,
        phrase_cache=None,
        modal_dispatcher=None,
        generic_audio_path: str = "/assets/generic"
    ):
        """
        Initialize fallback manager.
        
        Args:
            phrase_cache: LivePhraseCache instance
            modal_dispatcher: LiveAgentDispatcher instance
            generic_audio_path: Path to pre-recorded generic audio files
        """
        self.phrase_cache = phrase_cache
        self.modal_dispatcher = modal_dispatcher
        self.generic_audio_path = generic_audio_path
        self._stats = {
            FallbackLevel.CACHE: 0,
            FallbackLevel.LIVE_AGENT: 0,
            FallbackLevel.GENERIC: 0,
            FallbackLevel.TEXT_ONLY: 0,
        }
    
    async def get_commentary(
        self,
        event: Any,
        region: str,
        agent_type: str,
        timeout_ms: Optional[int] = None
    ) -> FallbackResult:
        """
        Get commentary with fallback chain.
        
        Tries each level in order until one succeeds.
        """
        start_time = time.time()
        
        # Get timeout from event or use default
        if timeout_ms is None:
            timeout_ms = getattr(event, 'latency_budget_ms', 500)
        
        event_type = getattr(event, 'event_type', None)
        if hasattr(event_type, 'value'):
            event_type = event_type.value
        else:
            event_type = str(event_type) if event_type else "default"
        
        # Level 1: Try phrase cache (instant)
        result = await self._try_cache(event_type, region, agent_type)
        if result:
            self._stats[FallbackLevel.CACHE] += 1
            result.latency_ms = int((time.time() - start_time) * 1000)
            return result
        
        # Level 2: Try Modal agent (timeout-bounded)
        result = await self._try_live_agent(event, region, agent_type, timeout_ms)
        if result:
            self._stats[FallbackLevel.LIVE_AGENT] += 1
            result.latency_ms = int((time.time() - start_time) * 1000)
            return result
        
        # Level 3: Try generic pre-recorded
        result = await self._try_generic(event_type, region)
        if result:
            self._stats[FallbackLevel.GENERIC] += 1
            result.latency_ms = int((time.time() - start_time) * 1000)
            return result
        
        # Level 4: Fall back to text-only
        self._stats[FallbackLevel.TEXT_ONLY] += 1
        return FallbackResult(
            level=FallbackLevel.TEXT_ONLY,
            text=self._get_text_reaction(event_type, region),
            audio=None,
            region=region,
            agent_type=agent_type,
            latency_ms=int((time.time() - start_time) * 1000),
            success=True,
            error="All audio fallbacks failed"
        )
    
    async def _try_cache(
        self, 
        event_type: str, 
        region: str, 
        agent_type: str
    ) -> Optional[FallbackResult]:
        """Level 1: Try phrase cache"""
        if not self.phrase_cache:
            return None
        
        try:
            reaction = await self.phrase_cache.get_instant_reaction(
                region=region,
                agent_type=agent_type,
                event_type=event_type
            )
            
            if reaction:
                return FallbackResult(
                    level=FallbackLevel.CACHE,
                    text=reaction.text,
                    audio=reaction.audio_base64,
                    region=region,
                    agent_type=agent_type,
                    latency_ms=0,
                    success=True
                )
        except Exception as e:
            logger.warning(f"Cache fallback failed: {e}")
        
        return None
    
    async def _try_live_agent(
        self,
        event: Any,
        region: str,
        agent_type: str,
        timeout_ms: int
    ) -> Optional[FallbackResult]:
        """Level 2: Try Modal agent with timeout"""
        if not self.modal_dispatcher:
            return None
        
        try:
            response = await asyncio.wait_for(
                self.modal_dispatcher._spawn_agent(event, region, agent_type),
                timeout=timeout_ms / 1000
            )
            
            if response:
                return FallbackResult(
                    level=FallbackLevel.LIVE_AGENT,
                    text=response.text,
                    audio=None,  # Audio would be generated separately
                    region=region,
                    agent_type=agent_type,
                    latency_ms=response.latency_ms,
                    success=True
                )
        except asyncio.TimeoutError:
            logger.warning(f"Live agent timed out after {timeout_ms}ms")
        except Exception as e:
            logger.warning(f"Live agent fallback failed: {e}")
        
        return None
    
    async def _try_generic(
        self, 
        event_type: str, 
        region: str
    ) -> Optional[FallbackResult]:
        """Level 3: Try pre-recorded generic reaction"""
        generic = self.GENERIC_REACTIONS.get(
            event_type, 
            self.GENERIC_REACTIONS["default"]
        )
        
        # Try to load pre-recorded audio
        audio = await self._load_generic_audio(event_type, region)
        
        if audio or True:  # Always return generic text even without audio
            return FallbackResult(
                level=FallbackLevel.GENERIC,
                text=generic["text"],
                audio=audio,
                region=region,
                agent_type="generic",
                latency_ms=0,
                success=True
            )
        
        return None
    
    async def _load_generic_audio(
        self, 
        event_type: str, 
        region: str
    ) -> Optional[str]:
        """Load pre-recorded audio file"""
        import base64
        
        # Try region-specific first, then default
        paths = [
            f"{self.generic_audio_path}/{region}_{event_type}.wav",
            f"{self.generic_audio_path}/default_{event_type}.wav",
        ]
        
        for path in paths:
            try:
                import os
                if os.path.exists(path):
                    with open(path, "rb") as f:
                        audio_data = f.read()
                    return base64.b64encode(audio_data).decode()
            except:
                continue
        
        return None
    
    def _get_text_reaction(self, event_type: str, region: str) -> str:
        """Level 4: Generate text-only reaction"""
        generic = self.GENERIC_REACTIONS.get(
            event_type, 
            self.GENERIC_REACTIONS["default"]
        )
        
        return f"[{region.upper()}] {generic['text']}"
    
    def get_stats(self) -> dict:
        """Get fallback usage statistics"""
        total = sum(self._stats.values())
        
        return {
            "total_requests": total,
            "by_level": {
                level.value: count
                for level, count in self._stats.items()
            },
            "cache_rate": (
                self._stats[FallbackLevel.CACHE] / total * 100
                if total > 0 else 0
            ),
            "text_only_rate": (
                self._stats[FallbackLevel.TEXT_ONLY] / total * 100
                if total > 0 else 0
            ),
        }
    
    def reset_stats(self):
        """Reset statistics"""
        for level in FallbackLevel:
            self._stats[level] = 0


# Factory function
def create_fallback_manager(phrase_cache=None, modal_dispatcher=None) -> LiveFallbackManager:
    """Create a configured fallback manager"""
    return LiveFallbackManager(
        phrase_cache=phrase_cache,
        modal_dispatcher=modal_dispatcher
    )


if __name__ == "__main__":
    # Test the fallback manager
    async def test():
        from dataclasses import dataclass
        
        @dataclass
        class MockEvent:
            event_type: str = "touchdown"
            latency_budget_ms: int = 150
        
        manager = LiveFallbackManager()
        
        event = MockEvent()
        result = await manager.get_commentary(event, "kansas_city", "homer")
        
        print(f"\nFallback Level: {result.level.value}")
        print(f"Text: {result.text}")
        print(f"Has Audio: {bool(result.audio)}")
        print(f"Latency: {result.latency_ms}ms")
        print(f"\nStats: {manager.get_stats()}")
    
    asyncio.run(test())
